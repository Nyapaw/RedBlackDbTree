{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RedBlackDbTree is a tweaked Red-black tree . I have created it because from my knowledge, there isn't any available, efficient method for sorting on Roblox already. If you find any issues, or if something is incorrect, open an issue on GitHub ! RedBlackDbTree Time complexity: Function Amortized Worst Case Search O(1) O(1) Add O(1) O(log n ) Delete O(1) O(log n )","title":"Home"},{"location":"api-reference/","text":"Summary \u00b6 RedBlackDbTree is a utility module allowing sorting of objects based on their natural order or a given key function. RedBlackDbTree has a special function called RedBlackDbTree.new() which is used to instantiate a new RedBlackDbTree Instance. This function can take a key function as a parameter to compare and sort objects by. Methods \u00b6 Add (object: any): nil Adds the given object to the tree, if it isn't already in the tree. AddAll (...): nil Adds the given objects to the tree using Add . Remove (object: any): nil Removes the given object from the tree, if it is present in the tree. RemoveAll (...): nil Removes the given objects to the tree using Remove . SetKey (key: (object: any) -> {values: Comparable | {Value: Comparable, Descending: boolean}}): nil Sets the key function of the tree, and refreshes its contents. If no key is given, the key will be set to default. ContainsObject (object): nil Returns true if the tree contains the given object, false otherwise. UpdateObject (object): nil Alerts the tree of an update within the given object. Clear (): nil Removes all objects from the tree, making it empty. Refresh (): nil Completely refreshes the tree by clearing its items, then re-inserting them. IsEmpty (): nil Returns true if the tree is empty, false otherwise. Height (): number Returns the height of the tree. A one-node tree has height 0. __len (): number Returns the number of non-nil nodes in the tree accesed by the # size operator. Min (): object Returns smallest object in the tree Max (): object Returns largest object in the tree RemoveMin (): nil Removes the smallest object from the tree. RemoveMax (): nil Removes the largest object from the tree. PreOrderArray (): {object} Returns a new array of the tree's objects in pre-order format. InOrderArray (): {object} Returns a new array of the tree's objects in the in-order format. PostOrderArray (): {object} Returns a new array of the tree's objects in post-order format. PreOrderPrint (): nil Prints the tree's objects in pre-order format. InOrderPrint (): nil Prints the tree's objects in the in-order format. PostOrderPrint (): nil Prints the tree's objects in post-order format. Constructors \u00b6 RedBlackDbTree.new \u00b6 RedBlackDbTree . new () -> RedBlackDBTree Creates a new, empty RedBlackDbTree using the natural ordering of its objects. Caution The only objects who may be sorted by the default key function are strings, numbers or metatables with comparison methods. RedBlackDbTree . new ( key : ( object : any ) -> { values : Comparable | { Value : Comparable , Descending : boolean }}) Creates a new, empty RedBlackDbTree, ordered according to the given key . The key should take one argument representing the object passed into it to return the desired object values (as a Tuple). If a value should be sorted descending, the value may be turned into a dictionary where Value represents the value and Descending is the boolean stating that the value should be descending. A key example may be seen here . Note RedBlackDbTree no longer uses a comparator, and uses a key-value system instead. Methods \u00b6 Info self is an active RedBlackDbTree Instance. Add \u00b6 self : Add ( object : any ) Adds object to the tree, given it is not in the array already. Caution If object is mutable, it must be updated using UpdateObject . Alternatively, the object can be removed, updated then added back in. AddAll \u00b6 self : AddAll ( ... ) Adds all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be added. Remove \u00b6 self : Remove ( object : any ) Removes object from the tree. RemoveAll \u00b6 self : RemoveAll ( ... ) Removes all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be removed. SetKey \u00b6 self : SetKey ( key : ( object : any ) -> { values : Comparable | { Value : Comparable , Descending : boolean }}) Sets the key function of the tree, and refreshes its contents. If no key is given, the key will be set to default. ContainsObject \u00b6 self : ContainsObject ( object ) -> boolean Returns true if the tree contains object , false otherwise. UpdateObject \u00b6 self : UpdateObject ( object ) Alerts the tree that an update has occured on the given object, and re-positions the object correctly. Clear \u00b6 self : Clear () Remove all objects from the tree, making it empty. Refresh \u00b6 self : Refresh () Completely refreshes the tree by clearing its items, then re-inserting them. IsEmpty \u00b6 self : IsEmpty () -> boolean Returns true if the tree is empty, false otherwise. Height \u00b6 self : Height () Returns the height of the tree. A one-node tree has height 0. __len \u00b6 # self -> number Returns the number of non-nil nodes in the tree. self should be a RedBlackDbTree instance. Min \u00b6 self : Min () -> object Returns the smallest object in the tree. Caution An error will be produced if there are no objects in the tree. Max \u00b6 self : Max () -> object Returns the largest object in the tree. Caution An error will be produced if there are no objects in the tree. RemoveMin \u00b6 self : RemoveMin () Removes the smallest object from the tree. Caution An error will be produced if there are no objects in the tree. RemoveMax \u00b6 self : RemoveMax () Removes the largest object from the tree Caution An error will be produced if there are no objects in the tree. PreOrderArray \u00b6 self : PreOrderArray () -> { object } Returns a new array of the tree's objects in pre-order format. InOrderArray \u00b6 self : InOrderArray () -> { object } Returns a new array of the tree's objects in the in-order format. PostOrderArray \u00b6 self : PostOrderArray () -> { object } Returns a new array of the tree's objects in post-order format. PreOrderPrint \u00b6 self : PreOrderPrint () Prints the tree's objects in pre-order format. InOrderPrint \u00b6 self : InOrderPrint () Prints the tree's objects in the in-order format. PostOrderPrint \u00b6 self : PostOrderPrint () Prints the tree's objects in post-order format.","title":"API Reference"},{"location":"api-reference/#summary","text":"RedBlackDbTree is a utility module allowing sorting of objects based on their natural order or a given key function. RedBlackDbTree has a special function called RedBlackDbTree.new() which is used to instantiate a new RedBlackDbTree Instance. This function can take a key function as a parameter to compare and sort objects by.","title":"Summary"},{"location":"api-reference/#methods","text":"Add (object: any): nil Adds the given object to the tree, if it isn't already in the tree. AddAll (...): nil Adds the given objects to the tree using Add . Remove (object: any): nil Removes the given object from the tree, if it is present in the tree. RemoveAll (...): nil Removes the given objects to the tree using Remove . SetKey (key: (object: any) -> {values: Comparable | {Value: Comparable, Descending: boolean}}): nil Sets the key function of the tree, and refreshes its contents. If no key is given, the key will be set to default. ContainsObject (object): nil Returns true if the tree contains the given object, false otherwise. UpdateObject (object): nil Alerts the tree of an update within the given object. Clear (): nil Removes all objects from the tree, making it empty. Refresh (): nil Completely refreshes the tree by clearing its items, then re-inserting them. IsEmpty (): nil Returns true if the tree is empty, false otherwise. Height (): number Returns the height of the tree. A one-node tree has height 0. __len (): number Returns the number of non-nil nodes in the tree accesed by the # size operator. Min (): object Returns smallest object in the tree Max (): object Returns largest object in the tree RemoveMin (): nil Removes the smallest object from the tree. RemoveMax (): nil Removes the largest object from the tree. PreOrderArray (): {object} Returns a new array of the tree's objects in pre-order format. InOrderArray (): {object} Returns a new array of the tree's objects in the in-order format. PostOrderArray (): {object} Returns a new array of the tree's objects in post-order format. PreOrderPrint (): nil Prints the tree's objects in pre-order format. InOrderPrint (): nil Prints the tree's objects in the in-order format. PostOrderPrint (): nil Prints the tree's objects in post-order format.","title":"Methods"},{"location":"api-reference/#constructors","text":"","title":"Constructors"},{"location":"api-reference/#redblackdbtreenew","text":"RedBlackDbTree . new () -> RedBlackDBTree Creates a new, empty RedBlackDbTree using the natural ordering of its objects. Caution The only objects who may be sorted by the default key function are strings, numbers or metatables with comparison methods. RedBlackDbTree . new ( key : ( object : any ) -> { values : Comparable | { Value : Comparable , Descending : boolean }}) Creates a new, empty RedBlackDbTree, ordered according to the given key . The key should take one argument representing the object passed into it to return the desired object values (as a Tuple). If a value should be sorted descending, the value may be turned into a dictionary where Value represents the value and Descending is the boolean stating that the value should be descending. A key example may be seen here . Note RedBlackDbTree no longer uses a comparator, and uses a key-value system instead.","title":"RedBlackDbTree.new"},{"location":"api-reference/#methods_1","text":"Info self is an active RedBlackDbTree Instance.","title":"Methods"},{"location":"api-reference/#add","text":"self : Add ( object : any ) Adds object to the tree, given it is not in the array already. Caution If object is mutable, it must be updated using UpdateObject . Alternatively, the object can be removed, updated then added back in.","title":"Add"},{"location":"api-reference/#addall","text":"self : AddAll ( ... ) Adds all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be added.","title":"AddAll"},{"location":"api-reference/#remove","text":"self : Remove ( object : any ) Removes object from the tree.","title":"Remove"},{"location":"api-reference/#removeall","text":"self : RemoveAll ( ... ) Removes all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be removed.","title":"RemoveAll"},{"location":"api-reference/#setkey","text":"self : SetKey ( key : ( object : any ) -> { values : Comparable | { Value : Comparable , Descending : boolean }}) Sets the key function of the tree, and refreshes its contents. If no key is given, the key will be set to default.","title":"SetKey"},{"location":"api-reference/#containsobject","text":"self : ContainsObject ( object ) -> boolean Returns true if the tree contains object , false otherwise.","title":"ContainsObject"},{"location":"api-reference/#updateobject","text":"self : UpdateObject ( object ) Alerts the tree that an update has occured on the given object, and re-positions the object correctly.","title":"UpdateObject"},{"location":"api-reference/#clear","text":"self : Clear () Remove all objects from the tree, making it empty.","title":"Clear"},{"location":"api-reference/#refresh","text":"self : Refresh () Completely refreshes the tree by clearing its items, then re-inserting them.","title":"Refresh"},{"location":"api-reference/#isempty","text":"self : IsEmpty () -> boolean Returns true if the tree is empty, false otherwise.","title":"IsEmpty"},{"location":"api-reference/#height","text":"self : Height () Returns the height of the tree. A one-node tree has height 0.","title":"Height"},{"location":"api-reference/#__len","text":"# self -> number Returns the number of non-nil nodes in the tree. self should be a RedBlackDbTree instance.","title":"__len"},{"location":"api-reference/#min","text":"self : Min () -> object Returns the smallest object in the tree. Caution An error will be produced if there are no objects in the tree.","title":"Min"},{"location":"api-reference/#max","text":"self : Max () -> object Returns the largest object in the tree. Caution An error will be produced if there are no objects in the tree.","title":"Max"},{"location":"api-reference/#removemin","text":"self : RemoveMin () Removes the smallest object from the tree. Caution An error will be produced if there are no objects in the tree.","title":"RemoveMin"},{"location":"api-reference/#removemax","text":"self : RemoveMax () Removes the largest object from the tree Caution An error will be produced if there are no objects in the tree.","title":"RemoveMax"},{"location":"api-reference/#preorderarray","text":"self : PreOrderArray () -> { object } Returns a new array of the tree's objects in pre-order format.","title":"PreOrderArray"},{"location":"api-reference/#inorderarray","text":"self : InOrderArray () -> { object } Returns a new array of the tree's objects in the in-order format.","title":"InOrderArray"},{"location":"api-reference/#postorderarray","text":"self : PostOrderArray () -> { object } Returns a new array of the tree's objects in post-order format.","title":"PostOrderArray"},{"location":"api-reference/#preorderprint","text":"self : PreOrderPrint () Prints the tree's objects in pre-order format.","title":"PreOrderPrint"},{"location":"api-reference/#inorderprint","text":"self : InOrderPrint () Prints the tree's objects in the in-order format.","title":"InOrderPrint"},{"location":"api-reference/#postorderprint","text":"self : PostOrderPrint () Prints the tree's objects in post-order format.","title":"PostOrderPrint"},{"location":"guide/advanced-custom-key/","text":"Info Assuming we have already implimented RedBlackDbTree as RedBlackDbTree Caution It is reccommend that if the values are comparable, they do not change, unless they are manually removed before the change and added back. In this example, we create an example class GroceryItem to display another way to sort items. Using metatables: \u00b6 local GroceryItem = {} -- Create a custom class for grocery items do GroceryItem . __index = GroceryItem -- Our simple grocery item constructor function GroceryItem . new ( name : string , price : number ) : GroceryItem return setmetatable ({ Name = name ; -- The name of the item Price = price ; -- The price of the item }, GroceryItem ) end -- lt is the required comparator method for the tree to work with direct object comparisons function GroceryItem . __lt ( item1 : GroceryItem , item2 : GroceryItem ): boolean if item1 . Price == item2 . Price then return item1 . Name > item2 . Name else return item1 . Price > item2 . Price end end end -- Create a list of our grocery items local groceryItems = { GroceryItem . new ( \"Cheese\" , 16 ), GroceryItem . new ( \"Ham\" , 16 ), GroceryItem . new ( \"Apple Pie\" , 16 ), GroceryItem . new ( \"Bread\" , 5 ), GroceryItem . new ( \"Steak\" , 30 ) } -- Since our items have their own comparison method, we do not need to create a key function. local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( groceryItems ) -- Add objects into the tree -- Print the grocery data in order. for idx , groceryItem in pairs ( tree : InOrderArray ()) do print ( \"Item #\" .. idx .. \" - Name: \" .. groceryItem . Name .. \", Price: $\" .. groceryItem . Price ) end When you run your game, the following should be printed to the console: Item #1 - Name: Steak, Price: $30 Item #2 - Name: Ham, Price: $16 Item #3 - Name: Cheese, Price: $16 Item #4 - Name: Apple Pie, Price: $16 Item #5 - Name: Bread, Price: $5","title":"Advanced Custom Key"},{"location":"guide/advanced-custom-key/#using-metatables","text":"local GroceryItem = {} -- Create a custom class for grocery items do GroceryItem . __index = GroceryItem -- Our simple grocery item constructor function GroceryItem . new ( name : string , price : number ) : GroceryItem return setmetatable ({ Name = name ; -- The name of the item Price = price ; -- The price of the item }, GroceryItem ) end -- lt is the required comparator method for the tree to work with direct object comparisons function GroceryItem . __lt ( item1 : GroceryItem , item2 : GroceryItem ): boolean if item1 . Price == item2 . Price then return item1 . Name > item2 . Name else return item1 . Price > item2 . Price end end end -- Create a list of our grocery items local groceryItems = { GroceryItem . new ( \"Cheese\" , 16 ), GroceryItem . new ( \"Ham\" , 16 ), GroceryItem . new ( \"Apple Pie\" , 16 ), GroceryItem . new ( \"Bread\" , 5 ), GroceryItem . new ( \"Steak\" , 30 ) } -- Since our items have their own comparison method, we do not need to create a key function. local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( groceryItems ) -- Add objects into the tree -- Print the grocery data in order. for idx , groceryItem in pairs ( tree : InOrderArray ()) do print ( \"Item #\" .. idx .. \" - Name: \" .. groceryItem . Name .. \", Price: $\" .. groceryItem . Price ) end When you run your game, the following should be printed to the console: Item #1 - Name: Steak, Price: $30 Item #2 - Name: Ham, Price: $16 Item #3 - Name: Cheese, Price: $16 Item #4 - Name: Apple Pie, Price: $16 Item #5 - Name: Bread, Price: $5","title":"Using metatables:"},{"location":"guide/array-retrieval/","text":"Info Assuming we have already implimented RedBlackDbTree as RedBlackDbTree Retrieving the sorted array: \u00b6 local result local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object result = tree : InOrderArray () -- Store the in-order array in `result` print ( result ) -- print the result When you run your game, the following should be printed to the console (you may need to expand the table): { [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9 }","title":"Array Retrieval"},{"location":"guide/array-retrieval/#retrieving-the-sorted-array","text":"local result local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object result = tree : InOrderArray () -- Store the in-order array in `result` print ( result ) -- print the result When you run your game, the following should be printed to the console (you may need to expand the table): { [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9 }","title":"Retrieving the sorted array:"},{"location":"guide/custom-key/","text":"Info Assuming we have already implimented RedBlackDbTree as RedBlackDbTree In this example, we create a custom key which identifies the sort order. Creating a custom key: \u00b6 -- The list of our test items local groceryItems = { {[ \"Name\" ] = \"Cheese\" , [ \"Price\" ] = 16 }, {[ \"Name\" ] = \"Ham\" , [ \"Price\" ] = 16 }, {[ \"Name\" ] = \"Apple Pie\" , [ \"Price\" ] = 16 }, {[ \"Name\" ] = \"Bread\" , [ \"Price\" ] = 5 }, {[ \"Name\" ] = \"Steak\" , [ \"Price\" ] = 30 } } -- Our key function first compares items by their price (descending), then their names (decending) -- Note that numbers may be made negative to invert sort order function groceryKey ( groceryItem ) return - groceryItem . Price , {[ \"Value\" ] = groceryItem . Name , [ \"Descending\" ] = true } end local tree = RedBlackDbTree . new ( groceryKey ) -- Instantiate the tree with the key tree : AddAll ( groceryItems ) -- Add objects into the tree -- Print the grocery data in order. for idx , groceryItem in pairs ( tree : InOrderArray ()) do print ( \"Item #\" .. idx .. \" - Name: \" .. groceryItem . Name .. \", Price: $\" .. groceryItem . Price ) end When you run your game, the following should be printed to the console: Item #1 - Name: Steak, Price: $30 Item #2 - Name: Ham, Price: $16 Item #3 - Name: Cheese, Price: $16 Item #4 - Name: Apple Pie, Price: $16 Item #5 - Name: Bread, Price: $5","title":"Custom Key"},{"location":"guide/custom-key/#creating-a-custom-key","text":"-- The list of our test items local groceryItems = { {[ \"Name\" ] = \"Cheese\" , [ \"Price\" ] = 16 }, {[ \"Name\" ] = \"Ham\" , [ \"Price\" ] = 16 }, {[ \"Name\" ] = \"Apple Pie\" , [ \"Price\" ] = 16 }, {[ \"Name\" ] = \"Bread\" , [ \"Price\" ] = 5 }, {[ \"Name\" ] = \"Steak\" , [ \"Price\" ] = 30 } } -- Our key function first compares items by their price (descending), then their names (decending) -- Note that numbers may be made negative to invert sort order function groceryKey ( groceryItem ) return - groceryItem . Price , {[ \"Value\" ] = groceryItem . Name , [ \"Descending\" ] = true } end local tree = RedBlackDbTree . new ( groceryKey ) -- Instantiate the tree with the key tree : AddAll ( groceryItems ) -- Add objects into the tree -- Print the grocery data in order. for idx , groceryItem in pairs ( tree : InOrderArray ()) do print ( \"Item #\" .. idx .. \" - Name: \" .. groceryItem . Name .. \", Price: $\" .. groceryItem . Price ) end When you run your game, the following should be printed to the console: Item #1 - Name: Steak, Price: $30 Item #2 - Name: Ham, Price: $16 Item #3 - Name: Cheese, Price: $16 Item #4 - Name: Apple Pie, Price: $16 Item #5 - Name: Bread, Price: $5","title":"Creating a custom key:"},{"location":"guide/implimentation/","text":"Add a new Script object to ServerScriptService in Roblox Studio. Using Method 1: \u00b6 local RedBlackDbTree = require ( 11328824364 ) -- Impliment the module Using Method 2: \u00b6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local RedBlackDbTree = require ( ReplicatedStorage . RedBlackDbTree ) -- Impliment the module Info Method 2 assumes you've successfuly installed RedBlackDbTree into ReplicatedStorage After using a provided method: \u00b6 local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object tree : InOrderPrint () When you run your game, the following should be printed to the console: 1 Color: B 2 Color: B 3 Color: B 4 Color: B 5 Color: B 6 Color: R 7 Color: B 8 Color: B 9 Color: B Congrats!","title":"Implimentation"},{"location":"guide/implimentation/#using-method-1","text":"local RedBlackDbTree = require ( 11328824364 ) -- Impliment the module","title":"Using Method 1:"},{"location":"guide/implimentation/#using-method-2","text":"local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local RedBlackDbTree = require ( ReplicatedStorage . RedBlackDbTree ) -- Impliment the module Info Method 2 assumes you've successfuly installed RedBlackDbTree into ReplicatedStorage","title":"Using Method 2:"},{"location":"guide/implimentation/#after-using-a-provided-method","text":"local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object tree : InOrderPrint () When you run your game, the following should be printed to the console: 1 Color: B 2 Color: B 3 Color: B 4 Color: B 5 Color: B 6 Color: R 7 Color: B 8 Color: B 9 Color: B Congrats!","title":"After using a provided method:"},{"location":"guide/installation/","text":"There are two supported ways to impliment RedBlackDbTree on Roblox. For my examples, RedBlackDbTree will be installed to ReplicatedStorage or accesed via require . The module may be installed anywhere as desired, though. Method 1: Roblox's built in require method \u00b6 Inside your script, you can require the module directly. Method 2: Model File (Roblox Studio) \u00b6 Download the rbxm model file from the RedBlackDbTree GitHub Insert the model into Roblox Studio in a place like ReplicatedStorage","title":"Installation"},{"location":"guide/installation/#method-1-robloxs-built-in-require-method","text":"Inside your script, you can require the module directly.","title":"Method 1: Roblox's built in require method"},{"location":"guide/installation/#method-2-model-file-roblox-studio","text":"Download the rbxm model file from the RedBlackDbTree GitHub Insert the model into Roblox Studio in a place like ReplicatedStorage","title":"Method 2: Model File (Roblox Studio)"},{"location":"guide/mutable-objects/","text":"Info Assuming we have already implimented RedBlackDbTree as RedBlackDbTree In this example, we use Part objects. Utilizing mutable objects: \u00b6 local START_POSITION = Vector3 . new ( - 1 , 0.5 , 18 ) -- The start position for our parts local PART_OFFSET = Vector3 . new ( 4 , 0 , 0 ) function createNewPart ( name , position ) local part = Instance . new ( \"Part\" ) part . Anchored = true part . Position = position part . Name = name part . Parent = workspace return part end -- Create a key based on a parts X - position function partXKey ( part ) return part . Position . X end local removePart = createNewPart ( \"REMOVEME\" , START_POSITION ) local movePart = createNewPart ( \"MOVEME\" , START_POSITION + PART_OFFSET * 2 ) local tree = RedBlackDbTree . new ( partXKey ) -- Instantiate the tree with the key tree : AddAll ( createNewPart ( \"P1\" , START_POSITION ), createNewPart ( \"P2\" , START_POSITION + PART_OFFSET ), movePart , removePart ) -- Add objects into the tree tree : Remove ( removePart ) -- Remove \"removePart\" movePart . Position = START_POSITION - PART_OFFSET -- Move `movePart` left of P1 tree : UpdateObject ( movePart ) -- Tell the tree that we updated an object tree : InOrderPrint () When you run your game, the following should be printed to the console: MOVEME Color B P1 Color B P2 Color B Since we updated movePart to be left of P1, it is now considered the \"smallest\".","title":"Mutable Objects"},{"location":"guide/mutable-objects/#utilizing-mutable-objects","text":"local START_POSITION = Vector3 . new ( - 1 , 0.5 , 18 ) -- The start position for our parts local PART_OFFSET = Vector3 . new ( 4 , 0 , 0 ) function createNewPart ( name , position ) local part = Instance . new ( \"Part\" ) part . Anchored = true part . Position = position part . Name = name part . Parent = workspace return part end -- Create a key based on a parts X - position function partXKey ( part ) return part . Position . X end local removePart = createNewPart ( \"REMOVEME\" , START_POSITION ) local movePart = createNewPart ( \"MOVEME\" , START_POSITION + PART_OFFSET * 2 ) local tree = RedBlackDbTree . new ( partXKey ) -- Instantiate the tree with the key tree : AddAll ( createNewPart ( \"P1\" , START_POSITION ), createNewPart ( \"P2\" , START_POSITION + PART_OFFSET ), movePart , removePart ) -- Add objects into the tree tree : Remove ( removePart ) -- Remove \"removePart\" movePart . Position = START_POSITION - PART_OFFSET -- Move `movePart` left of P1 tree : UpdateObject ( movePart ) -- Tell the tree that we updated an object tree : InOrderPrint () When you run your game, the following should be printed to the console: MOVEME Color B P1 Color B P2 Color B Since we updated movePart to be left of P1, it is now considered the \"smallest\".","title":"Utilizing mutable objects:"}]}