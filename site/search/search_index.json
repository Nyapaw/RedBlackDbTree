{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RedBlackDbTree is a tweaked Red-black tree . I have created it because from my knowledge, there isn't any available, efficient sorting data structures on Roblox already. If you find any issues, or if something is incorrect, open an issue on GitHub ! RedBlackDbTree Time complexity: Function Amortized Worst Case Search O(1) O(1) Add O(1) O(log n ) Delete O(1) O(log n )","title":"Home"},{"location":"api-reference/","text":"Constructors \u00b6 RedBlackDbTree.new \u00b6 RedBlackDbTree . new () -> RedBlackDBTree Creates a new, empty RedBlackDbTree using the natural ordering of its objects. Caution The only objects who may be sorted by the default comparator are Strings, numbers or Metatables with comparison methods. RedBlackDbTree . new ( comparator : ( object1 , object2 ) -> number ) -> RedBlackDbTree Creates a new, empty RedBlackDbTree, ordered according to the given comparator . The comparator should take two arguments representing the objects passed into it. The main 3 cases are listed below: If object1 is \"smaller\" than object2 , a negative number should be returned If object1 is \"greater\" than object2 , a positive number should be returned If the two objects are considered equal, 0 should be returned Methods \u00b6 Info self is an active RedBlackDbTree Instance. Add \u00b6 self : Add ( object : any ) Adds object to the tree, given it is not in the array already. Caution If object is mutable, it must be updated using UpdateObject . Alternatively, the object can be removed, updated then added back in. AddAll \u00b6 self : AddAll ( ... ) Adds all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be added. Remove \u00b6 self : Remove ( object : any ) Removes object from the tree. RemoveAll \u00b6 self : RemoveAll ( ... ) Removes all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be removed. ContainsObject \u00b6 self : ContainsObject ( object ) -> boolean Returns true if the tree contains object , false otherwise. UpdateObject \u00b6 self : UpdateObject ( object , dict : {[ property ] = update }) - Removes the object from the tree Applies the update to the property of the object for all properties in dict Adds the updated object back into the tree at its correct location Caution Only mutable objects may be updated this way. An error will be thrown otherwise. Clear \u00b6 self : Clear () Remove all objects from the tree, making it empty. IsEmpty \u00b6 self : IsEmpty () -> boolean Returns true if the tree is empty, false otherwise. Height \u00b6 self : Height () Returns the height of the tree. A one-node tree has height 0. __len \u00b6 # self -> number Returns the number of non-nil nodes in the tree. self should be a RedBlackDbTree instance. Min \u00b6 self : Min () -> object Returns the smallest object in the tree. Caution An error will be produced if there are no objects in the tree. Max \u00b6 self : Max () -> object Returns the largest object in the tree. Caution An error will be produced if there are no objects in the tree. RemoveMin \u00b6 self : RemoveMin () Removes the \"smallest\" object from the tree. Caution An error will be produced if there are no objects in the tree. RemoveMax \u00b6 self : RemoveMax () Removes the \"largest\" object from the tree Caution An error will be produced if there are no objects in the tree. PreOrderArray \u00b6 self : PreOrderArray () -> { object } Returns a new array of the tree's objects in pre-order format. InOrderArray \u00b6 self : InOrderArray () -> { object } Returns a new array of the tree's objects in the in-order format. PostOrderArray \u00b6 self : PostOrderArray () -> { object } Returns a new array of the tree's objects in post-order format. PreOrderPrint \u00b6 self : PreOrderPrint () Prints the tree's objects in pre-order format. InOrderPrint \u00b6 self : InOrderPrint () Prints the tree's objects in the in-order format. PostOrderPrint \u00b6 self : PostOrderPrint () Prints the tree's objects in post-order format.","title":"API Reference"},{"location":"api-reference/#constructors","text":"","title":"Constructors"},{"location":"api-reference/#redblackdbtreenew","text":"RedBlackDbTree . new () -> RedBlackDBTree Creates a new, empty RedBlackDbTree using the natural ordering of its objects. Caution The only objects who may be sorted by the default comparator are Strings, numbers or Metatables with comparison methods. RedBlackDbTree . new ( comparator : ( object1 , object2 ) -> number ) -> RedBlackDbTree Creates a new, empty RedBlackDbTree, ordered according to the given comparator . The comparator should take two arguments representing the objects passed into it. The main 3 cases are listed below: If object1 is \"smaller\" than object2 , a negative number should be returned If object1 is \"greater\" than object2 , a positive number should be returned If the two objects are considered equal, 0 should be returned","title":"RedBlackDbTree.new"},{"location":"api-reference/#methods","text":"Info self is an active RedBlackDbTree Instance.","title":"Methods"},{"location":"api-reference/#add","text":"self : Add ( object : any ) Adds object to the tree, given it is not in the array already. Caution If object is mutable, it must be updated using UpdateObject . Alternatively, the object can be removed, updated then added back in.","title":"Add"},{"location":"api-reference/#addall","text":"self : AddAll ( ... ) Adds all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be added.","title":"AddAll"},{"location":"api-reference/#remove","text":"self : Remove ( object : any ) Removes object from the tree.","title":"Remove"},{"location":"api-reference/#removeall","text":"self : RemoveAll ( ... ) Removes all the given objects in the tuple ... If one object is given, it is assumed to be a table in which all values will be removed.","title":"RemoveAll"},{"location":"api-reference/#containsobject","text":"self : ContainsObject ( object ) -> boolean Returns true if the tree contains object , false otherwise.","title":"ContainsObject"},{"location":"api-reference/#updateobject","text":"self : UpdateObject ( object , dict : {[ property ] = update }) - Removes the object from the tree Applies the update to the property of the object for all properties in dict Adds the updated object back into the tree at its correct location Caution Only mutable objects may be updated this way. An error will be thrown otherwise.","title":"UpdateObject"},{"location":"api-reference/#clear","text":"self : Clear () Remove all objects from the tree, making it empty.","title":"Clear"},{"location":"api-reference/#isempty","text":"self : IsEmpty () -> boolean Returns true if the tree is empty, false otherwise.","title":"IsEmpty"},{"location":"api-reference/#height","text":"self : Height () Returns the height of the tree. A one-node tree has height 0.","title":"Height"},{"location":"api-reference/#__len","text":"# self -> number Returns the number of non-nil nodes in the tree. self should be a RedBlackDbTree instance.","title":"__len"},{"location":"api-reference/#min","text":"self : Min () -> object Returns the smallest object in the tree. Caution An error will be produced if there are no objects in the tree.","title":"Min"},{"location":"api-reference/#max","text":"self : Max () -> object Returns the largest object in the tree. Caution An error will be produced if there are no objects in the tree.","title":"Max"},{"location":"api-reference/#removemin","text":"self : RemoveMin () Removes the \"smallest\" object from the tree. Caution An error will be produced if there are no objects in the tree.","title":"RemoveMin"},{"location":"api-reference/#removemax","text":"self : RemoveMax () Removes the \"largest\" object from the tree Caution An error will be produced if there are no objects in the tree.","title":"RemoveMax"},{"location":"api-reference/#preorderarray","text":"self : PreOrderArray () -> { object } Returns a new array of the tree's objects in pre-order format.","title":"PreOrderArray"},{"location":"api-reference/#inorderarray","text":"self : InOrderArray () -> { object } Returns a new array of the tree's objects in the in-order format.","title":"InOrderArray"},{"location":"api-reference/#postorderarray","text":"self : PostOrderArray () -> { object } Returns a new array of the tree's objects in post-order format.","title":"PostOrderArray"},{"location":"api-reference/#preorderprint","text":"self : PreOrderPrint () Prints the tree's objects in pre-order format.","title":"PreOrderPrint"},{"location":"api-reference/#inorderprint","text":"self : InOrderPrint () Prints the tree's objects in the in-order format.","title":"InOrderPrint"},{"location":"api-reference/#postorderprint","text":"self : PostOrderPrint () Prints the tree's objects in post-order format.","title":"PostOrderPrint"},{"location":"guide/array-retrieval/","text":"Info Assuming we have already implimented RedBlackDbTree as RedBlackDbTree Retrieving the sorted array: \u00b6 local result local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object result = tree : InOrderArray () -- Store the in-order array in `result` print ( result ) -- print the result When you run your game, the following should be printed to the console (you may need to expand the table): { [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9 }","title":"Array Retrieval"},{"location":"guide/array-retrieval/#retrieving-the-sorted-array","text":"local result local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object result = tree : InOrderArray () -- Store the in-order array in `result` print ( result ) -- print the result When you run your game, the following should be printed to the console (you may need to expand the table): { [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9 }","title":"Retrieving the sorted array:"},{"location":"guide/custom-comparator/","text":"Info Assuming we have already implimented RedBlackDbTree as RedBlackDbTree In this example, we create a custom comparator which sorts in decending order. Create a custom comparator: \u00b6 local tree function decOrderComparator ( object1 , object2 ) if object1 > object2 then return - 1 -- object1 is larger than object2 elseif object1 < object2 then return 1 -- object1 is smaller than object2 else return 0 -- object1 is equal to object2 end end tree = RedBlackDbTree . new ( decOrderComparator ) -- Instantiate the tree with the comparator tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object tree : InOrderPrint () When you run your game, the following should be printed to the console: 9 Color: B 8 Color: R 7 Color: B 6 Color: B 5 Color: B 4 Color: B 3 Color: B 2 Color: B 1 Color: B","title":"Custom Comparator"},{"location":"guide/custom-comparator/#create-a-custom-comparator","text":"local tree function decOrderComparator ( object1 , object2 ) if object1 > object2 then return - 1 -- object1 is larger than object2 elseif object1 < object2 then return 1 -- object1 is smaller than object2 else return 0 -- object1 is equal to object2 end end tree = RedBlackDbTree . new ( decOrderComparator ) -- Instantiate the tree with the comparator tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object tree : InOrderPrint () When you run your game, the following should be printed to the console: 9 Color: B 8 Color: R 7 Color: B 6 Color: B 5 Color: B 4 Color: B 3 Color: B 2 Color: B 1 Color: B","title":"Create a custom comparator:"},{"location":"guide/implimentation/","text":"Add a new Script object to ServerScriptService in Roblox Studio. Using Method 1: \u00b6 local RedBlackDbTree = require ( 11328824364 ) -- Impliment the module Using Method 2: \u00b6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local RedBlackDbTree = require ( ReplicatedStorage . RedBlackDbTree ) -- Impliment the module Info Method 2 assumes you've successfuly installed RedBlackDbTree into ReplicatedStorage After using a provided method: \u00b6 local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object tree : InOrderPrint () When you run your game, the following should be printed to the console: 1 Color: B 2 Color: B 3 Color: B 4 Color: B 5 Color: B 6 Color: R 7 Color: B 8 Color: B 9 Color: B Congrats!","title":"Implimentation"},{"location":"guide/implimentation/#using-method-1","text":"local RedBlackDbTree = require ( 11328824364 ) -- Impliment the module","title":"Using Method 1:"},{"location":"guide/implimentation/#using-method-2","text":"local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local RedBlackDbTree = require ( ReplicatedStorage . RedBlackDbTree ) -- Impliment the module Info Method 2 assumes you've successfuly installed RedBlackDbTree into ReplicatedStorage","title":"Using Method 2:"},{"location":"guide/implimentation/#after-using-a-provided-method","text":"local tree = RedBlackDbTree . new () -- Instantiate the tree tree : AddAll ( 5 , 6 , 8 , 9 , 2 , 1 , 4 , 109 ) -- Add objects into the tree tree : AddAll ({ 3 , 7 }) -- We can alternatively add objects like this tree : Remove ( 109 ) -- Remove an object tree : InOrderPrint () When you run your game, the following should be printed to the console: 1 Color: B 2 Color: B 3 Color: B 4 Color: B 5 Color: B 6 Color: R 7 Color: B 8 Color: B 9 Color: B Congrats!","title":"After using a provided method:"},{"location":"guide/installation/","text":"There are two supported ways to impliment RedBlackDbTree on Roblox. For my examples, RedBlackDbTree will be installed to ReplicatedStorage or accesed via require . The module may be installed anywhere as desired, though. Method 1: Roblox's built in require method \u00b6 Inside your script, you can require the module directly. Method 2: Model File (Roblox Studio) \u00b6 Download the rbxm model file from the RedBlackDbTree GitHub Insert the model into Roblox Studio in a place like ReplicatedStorage","title":"Installation"},{"location":"guide/installation/#method-1-robloxs-built-in-require-method","text":"Inside your script, you can require the module directly.","title":"Method 1: Roblox's built in require method"},{"location":"guide/installation/#method-2-model-file-roblox-studio","text":"Download the rbxm model file from the RedBlackDbTree GitHub Insert the model into Roblox Studio in a place like ReplicatedStorage","title":"Method 2: Model File (Roblox Studio)"},{"location":"guide/mutable-objects/","text":"Info Assuming we have already implimented RedBlackDbTree as RedBlackDbTree In this example, we use Part objects. Utilizing mutable objects: \u00b6 local START_POSITION = Vector3 . new ( - 1 , 0.5 , 18 ) -- The start position for our parts local PART_OFFSET = Vector3 . new ( 4 , 0 , 0 ) local removePart , movePart local tree function createNewPart ( name , position ) local part = Instance . new ( \"Part\" ) part . Anchored = true part . Position = position part . Name = name part . Parent = workspace return part end function partXComparator ( part1 , part2 ) if part1 == part2 or part1 . Position . X == part2 . Position . X then return 0 -- part1 equal to part2 or they have equal X positions elseif part1 . Position . X < part2 . Position . X then return - 1 -- part1 is more left than other else return 1 -- part1 is more right than other end end tree = RedBlackDbTree . new ( partXComparator ) -- Instantiate the tree with the comparator removePart = createNewPart ( \"REMOVEME\" , START_POSITION ) movePart = createNewPart ( \"MOVEME\" , START_POSITION + PART_OFFSET * 2 ) tree : AddAll ( createNewPart ( \"P1\" , START_POSITION ), createNewPart ( \"P2\" , START_POSITION + PART_OFFSET ), movePart , removePart ) -- Add objects into the tree tree : Remove ( removePart ) -- Remove `removePart` tree : UpdateObject ( movePart , { Position = START_POSITION - PART_OFFSET }) -- Move `movePart` left of P1 tree : InOrderPrint () When you run your game, the following should be printed to the console: MOVEME Color B P1 Color B P2 Color B Since we updated movePart to be left of P1, it is now considered the \"smallest\".","title":"Mutable Objects"},{"location":"guide/mutable-objects/#utilizing-mutable-objects","text":"local START_POSITION = Vector3 . new ( - 1 , 0.5 , 18 ) -- The start position for our parts local PART_OFFSET = Vector3 . new ( 4 , 0 , 0 ) local removePart , movePart local tree function createNewPart ( name , position ) local part = Instance . new ( \"Part\" ) part . Anchored = true part . Position = position part . Name = name part . Parent = workspace return part end function partXComparator ( part1 , part2 ) if part1 == part2 or part1 . Position . X == part2 . Position . X then return 0 -- part1 equal to part2 or they have equal X positions elseif part1 . Position . X < part2 . Position . X then return - 1 -- part1 is more left than other else return 1 -- part1 is more right than other end end tree = RedBlackDbTree . new ( partXComparator ) -- Instantiate the tree with the comparator removePart = createNewPart ( \"REMOVEME\" , START_POSITION ) movePart = createNewPart ( \"MOVEME\" , START_POSITION + PART_OFFSET * 2 ) tree : AddAll ( createNewPart ( \"P1\" , START_POSITION ), createNewPart ( \"P2\" , START_POSITION + PART_OFFSET ), movePart , removePart ) -- Add objects into the tree tree : Remove ( removePart ) -- Remove `removePart` tree : UpdateObject ( movePart , { Position = START_POSITION - PART_OFFSET }) -- Move `movePart` left of P1 tree : InOrderPrint () When you run your game, the following should be printed to the console: MOVEME Color B P1 Color B P2 Color B Since we updated movePart to be left of P1, it is now considered the \"smallest\".","title":"Utilizing mutable objects:"}]}